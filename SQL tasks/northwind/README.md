Решение задач с курса по SQL.
Файл с созданием и заполнением учебной БД.

1)[Простые выборки через SELECT](https://github.com/DistantLight/Java/blob/main/SQL%20tasks/northwind/1.sql)
  1. Выбрать все данные из таблицы customers
  
  2. Выбрать все записи из таблицы customers, но только колонки "имя контакта" и "город"
  
  3. Выбрать все записи из таблицы orders, но взять две колонки: идентификатор заказа и колонку, значение в которой мы рассчитываем как разницу между датой отгрузки и датой формирования заказа.
  
  4. Выбрать все уникальные города в которых "зарегестрированы" заказчики
  
  5. Выбрать все уникальные сочетания городов и стран в которых "зарегестрированы" заказчики
  
  6. Посчитать кол-во заказчиков
  
  7. Посчитать кол-во уникальных стран в которых "зарегестрированы" заказчики

2)Запросы с SELECT
  1. Выбрать все заказы из стран France, Austria, Spain
  
  2. Выбрать все заказы, отсортировать по required_date (по убыванию) и отсортировать по дате отгрузке (по возрастанию)
  
  3. Выбрать минимальное кол-во  единиц товара среди тех продуктов, которых в продаже более 30 единиц.
  
  4. Выбрать максимальное кол-во единиц товара среди тех продуктов, которых в продаже более 30 единиц.
  
  5. Найти среднее значение дней уходящих на доставку с даты формирования заказа в USA
  
  6. Найти сумму, на которую имеется товаров (кол-во * цену) причём таких, которые планируется продавать и в будущем (см. на поле discontinued)

3)Группировки, сопоставления и сортировки в SELECT
  1. Выбрать все записи заказов в которых наименование страны отгрузки начинается с 'U'
  
  2. Выбрать записи заказов (включить колонки идентификатора заказа, идентификатора заказчика, веса и страны отгузки), которые должны быть отгружены в страны имя которых начинается с 'N', отсортировать по весу (по убыванию) и вывести только первые 10 записей.
  
  3. Выбрать записи работников (включить колонки имени, фамилии, телефона, региона) в которых регион неизвестен
  
  4. Подсчитать кол-во заказчиков регион которых известен
  
  5. Подсчитать кол-во поставщиков в каждой из стран и отсортировать результаты группировки по убыванию кол-ва
  
  6. Подсчитать суммарный вес заказов (в которых известен регион) по странам, затем отфильтровать по суммарному весу (вывести только те записи где суммарный вес больше 2750) и отсортировать по убыванию суммарного веса.
  
  7. Выбрать все уникальные страны заказчиков и поставщиков и отсортировать страны по возрастанию
  
  8. Выбрать такие страны в которых "зарегистированы" одновременно и заказчики и поставщики и работники.
  
  9. Выбрать такие страны в которых "зарегистированы" одновременно заказчики и поставщики, но при этом в них не "зарегистрированы" работники.

4)JOINS
  1. Найти заказчиков и обслуживающих их заказы сотрудников таких, что и заказчики и сотрудники из города London, а доставка идёт компанией Speedy Express. Вывести компанию заказчика и ФИО сотрудника.
  
  2. Найти активные (см. поле discontinued) продукты из категории Beverages и Seafood, которых в продаже менее 20 единиц. Вывести наименование продуктов, кол-во единиц в продаже, имя контакта поставщика и его телефонный номер.
  
  3. Найти заказчиков, не сделавших ни одного заказа. Вывести имя заказчика и order_id.
  
  4. Переписать предыдущий запрос, использовав симметричный вид джойна (подсказка: речь о LEFT и RIGHT).

5)Подзапросы
  1. Вывести продукты количество которых в продаже меньше самого малого среднего количества продуктов в деталях заказов (группировка по product_id).
  Результирующая таблица должна иметь колонки product_name и units_in_stock.
  
  2. Напишите запрос, который выводит общую сумму фрахтов заказов для компаний-заказчиков для заказов, стоимость фрахта которых больше или равна средней величине
  стоимости фрахта всех заказов, а также дата отгрузки заказа должна находится во второй половине июля 1996 года. Результирующая таблица должна иметь колонки 
  customer_id и freight_sum, строки которой должны быть отсортированы по сумме фрахтов заказов.
  
  3. Напишите запрос, который выводит 3 заказа с наибольшей стоимостью, которые были созданы после 1 сентября 1997 года включительно. Общая стоимость рассчитывается 
  как сумма стоимости деталей заказа с учетом дисконта. Результирующая таблица должна иметь колонки customer_id, ship_country и order_price, строки которой должны 
  быть отсортированы по стоимости заказа в обратном порядке.
  
  4. Вывести все товары (уникальные названия продуктов), которых заказано ровно 10 единиц с помощью подзапроса.

6)DDL base
  1. Создать таблицу teacher с полями teacher_id serial, first_name varchar, last_name varchar, birthday date, phone varchar, title varchar
  
  2. Добавить в таблицу после создания колонку middle_name varchar
  
  3. Удалить колонку middle_name
  
  4. Переименовать колонку birthday в birth_date
  
  5. Изменить тип данных колонки phone на varchar(32)
  
  6. Создать таблицу exam с полями exam_id serial, exam_name varchar(256), exam_date date
  
  7. Вставить три любых записи с автогенерацией идентификатора
  
  8. Посредством полной выборки убедиться, что данные были вставлены нормально и идентификаторы были сгенерированы с инкрементом
  
  9. Удалить все данные из таблицы со сбросом идентификатор в исходное состояние

7)DDL ADVANCED
  1. Создать таблицу exam с полями:
  
  - идентификатора экзамена - автоинкрементируемый, уникальный, запрещает NULL;
  - наименования экзамена
  - даты экзамена
  
  2. Удалить ограничение уникальности с поля идентификатора
  
  3. Добавить ограничение первичного ключа на поле идентификатора
  
  4. Создать таблицу person с полями
  
  - идентификатора личности (простой int, первичный ключ)
  - имя
  - фамилия
  
  5. Создать таблицу паспорта с полями:
  
  - идентификатора паспорта (простой int, первичный ключ)
  - серийный номер (простой int, запрещает NULL)
  - регистрация
  - ссылка на идентификатор личности (внешний ключ)
  
  6. Добавить колонку веса в таблицу book (создавали ранее) с ограничением, проверяющим вес (больше 0 но меньше 100)
  
  7. Убедиться в том, что ограничение на вес работает (попробуйте вставить невалидное значение)
  
  8. Создать таблицу student с полями:
  - идентификатора (автоинкремент)
  - полное имя
  - курс (по умолчанию 1)
  
  9. Вставить запись в таблицу студентов и убедиться, что ограничение на вставку значения по умолчанию работает
  
  10. Удалить ограничение "по умолчанию" из таблицы студентов
  
  11. Подключиться к БД northwind и добавить ограничение на поле unit_price таблицы products (цена должна быть больше 0)
  
  12. "Навесить" автоинкрементируемый счётчик на поле product_id таблицы products (БД northwind). Счётчик должен начинаться с числа следующего за максимальным значением
  по этому столбцу.

8)Views
  1. Создать представление, которое выводит следующие колонки:
  
  order_date, required_date, shipped_date, ship_postal_code, company_name, contact_name, phone, last_name, first_name, title из таблиц orders, customers и employees.
  
  Сделать select к созданному представлению, выведя все записи, где order_date больше 1го января 1997 года.
  
  2. Создать представление, которое выводит следующие колонки:
  
  order_date, required_date, shipped_date, ship_postal_code, ship_country, company_name, contact_name, phone, last_name, first_name, title из таблиц orders, customers,
  employees.
  
  Попробовать добавить к представлению (после его создания) колонки ship_country, postal_code и reports_to. Убедиться, что проихсодит ошибка. Переименовать представление 
  и создать новое уже с дополнительными колонками.
  
  Сделать к нему запрос, выбрав все записи, отсортировав их по ship_county.
  
  Удалить переименованное представление.
  
  3.  Создать представление "активных" (discontinued = 0) продуктов, содержащее все колонки. Представление должно быть защищено от вставки записей, в которых 
  discontinued = 1.

9)Логика с CASE, COALESCE, NULLIF
  1. Выполните следующий код (записи необходимы для тестирования корректности выполнения ):
  
  insert into customers(customer_id, contact_name, city, country, company_name)
  values 
  ('AAAAA', 'Alfred Mann', NULL, 'USA', 'fake_company'),
  ('BBBBB', 'Alfred Mann', NULL, 'Austria','fake_company');
  
  После этого выполните задание:
  
  Вывести имя контакта заказчика, его город и страну, отсортировав по возрастанию по имени контакта и городу,
  
  а если город равен NULL, то по имени контакта и стране. Проверить результат, используя заранее вставленные строки.
  
  2. Вывести наименование продукта, цену продукта и столбец со значениями
  
  too expensive если цена >= 100
  
  average если цена >=50 но < 100
  
  low price если цена < 50
  
  3. Найти заказчиков, не сделавших ни одного заказа. Вывести имя заказчика и значение 'no orders' если order_id = NULL.
  
  4. Вывести ФИО сотрудников и их должности. В случае если должность = Sales Representative вывести вместо неё Sales Stuff.

10)Функции SQL и процедуры pl_pgSQL
  1. Создайте функцию, которая делает бэкап таблицы customers (копирует все данные в другую таблицу), предварительно стирая таблицу для бэкапа, если такая уже существует (чтобы в случае многократного запуска таблица для бэкапа перезатиралась).
  
  2. Создать функцию, которая возвращает средний фрахт (freight) по всем заказам
  
  3. Написать функцию, которая принимает два целочисленных параметра, используемых как нижняя и верхняя границы для генерации случайного числа в пределах этой границы (включая сами граничные значения).
  
  Функция random генерирует вещественное число от 0 до 1.
  
  Необходимо вычислить разницу между границами и прибавить единицу.
  
  На полученное число умножить результат функции random() и прибавить к результату значение нижней границы.
  
  Применить функцию floor() к конечному результату, чтобы не "уехать" за границу и получить целое число.
  
  4. Создать функцию, которая возвращает самые низкую и высокую зарплаты среди сотрудников заданного города
  
  5. Создать функцию, которая корректирует зарплату на заданный процент,  но не корректирует зарплату, если её уровень превышает заданный уровень при этом верхний уровень зарплаты по умолчанию равен 70, а процент коррекции равен 15%.
  
  6. Модифицировать функцию, корректирующую зарплату таким образом, чтобы в результате коррекции, она так же выводила бы изменённые записи.
  
  7. Модифицировать предыдущую функцию так, чтобы она возвращала только колонки last_name, first_name, title, salary
  
  8. Написать функцию, которая принимает метод доставки и возвращает записи из таблицы orders в которых freight меньше значения, определяемого по следующему алгоритму:
  
  - ищем максимум фрахта (freight) среди заказов по заданному методу доставки
  
  - корректируем найденный максимум на 30% в сторону понижения
  
  - вычисляем среднее значение фрахта среди заказов по заданному методому доставки
  
  - вычисляем среднее значение между средним найденным на предыдущем шаге и скорректированным максимумом
  
  - возвращаем все заказы в которых значение фрахта меньше найденного на предыдущем шаге среднего
  
  9. Написать функцию, которая принимает:
  
  уровень зарплаты, максимальную зарплату (по умолчанию 80) минимальную зарплату (по умолчанию 30), коээфициет роста зарплаты (по умолчанию 20%)
  
  Если зарплата выше минимальной, то возвращает false
  
  Если зарплата ниже минимальной, то увеличивает зарплату на коэффициент роста и проверяет не станет ли зарплата после повышения превышать максимальную.
  
  Если превысит - возвращает false, в противном случае true.
  
  Проверить реализацию, передавая следующие параметры
  
  (где c - уровень з/п, max - макс. уровень з/п, min - минимальный уровень з/п, r - коэффициент):
  
  c = 40, max = 80, min = 30, r = 0.2 - должна вернуть false
  
  c = 79, max = 81, min = 80, r = 0.2 - должна вернуть false
  
  c = 79, max = 95, min = 80, r = 0.2 - должна вернуть true

11)Обработка ошибок
  Имеется следующая функция:
  
  create or replace function should_increase_salary(
    cur_salary numeric,
    max_salary numeric DEFAULT 80, 
    min_salary numeric DEFAULT 30,
    increase_rate numeric DEFAULT 0.2
    ) returns bool AS $$
  declare
    new_salary numeric;
  begin
    if cur_salary >= max_salary or cur_salary >= min_salary then 		
      return false;
    end if;
    
    if cur_salary < min_salary then
      new_salary = cur_salary + (cur_salary * increase_rate);
    end if;
    
    if new_salary > max_salary then
      return false;
    else
      return true;
    end if;	
  end;
  $$ language plpgsql;
  
  Задание:
  Модифицировать функцию should_increase_salary таким образом, чтобы запретить (выбрасывая исключения) передачу аргументов так, что:
  
      -минимальный уровень з/п превышает максимальный
  
      -ни минимальный, ни максимальный уровень з/п не могут быть меньше нуля
  
      -коэффициент повышения зарплаты не может быть ниже 5%
  
  Протестировать реализацию, передавая следующие значения аргументов
  (с - уровень "проверяемой" зарплаты, r - коэффициент повышения зарплаты):
  
  c = 79, max = 10, min = 80, r = 0.2
  
  c = 79, max = 10, min = -1, r = 0.2
  
  c = 79, max = 10, min = 10, r = 0.04

12)Массивы
  Создать функцию, которая вычисляет средний фрахт по заданным странам (функция принимает список стран).

13)Массивы и циклы в pl_pgSQL
  Написать функцию, которая фильтрует телефонные номера по коду оператора.
  
  Принимает 3-х значный код мобильного оператора и список телефонных номеров в формате +1(234)5678901 (variadic)
  
  Функция возвращает только те номера, код оператора которых соответствует значению соответствующего аргумента.
  
  Проверить функцию передав следующие аргументы:
  
  903, +7(903)1901235, +7(926)8567589, +7(903)1532476
  
  Попробовать передать аргументы с созданием массива и без.

14)Пользовательские типы (ENUM)
  1. Переписать функцию таким образом, чтобы функция возвращала экземпляр композитного типа:
  
  create or replace function get_salary_boundaries_by_city(
  	emp_city varchar, out min_salary numeric, out max_salary numeric) 
  AS 
  $$
  	SELECT MIN(salary) AS min_salary,
  	   	   MAX(salary) AS max_salary
    	FROM employees
  	WHERE city = emp_city
  $$ language sql;
  
  
  2. Задание состоит из пунктов:
  
  Создать перечисление армейских званий США, включающее следующие значения: Private, Corporal, Sergeant
  
  Вывести все значения из перечисления.
  
  Добавить значение Major после Sergeant в перечисление
  
  Создать таблицу личного состава с колонками: person_id, first_name, last_name, person_rank (типа перечисления)
  
  Добавить несколько записей, вывести все записи из таблицы

15)Группировки с ROLLUP и CUBE
  1.Вывести сумму продаж (цена * кол-во) по каждому сотруднику с подсчётом полного итога (полной суммы по всем сотрудникам) 
  отсортировав по сумме продаж (по убыванию).

  2.Вывести отчёт показывающий сумму продаж по сотрудникам и странам отгрузки с подытогами по сотрудникам и общим итогом.

  3.Вывести отчёт показывающий сумму продаж по сотрудникам, странам отгрузки, сотрудникам и странам отгрузки с подытогами по 
  сотрудникам и общим итогом.

16)Оконные функции
   1. Вывести отчёт показывающий по сотрудникам суммы продаж SUM(unit_price*quantity), и сопоставляющий их со средним значением суммы продаж по сотрудникам
   (AVG по SUM(unit_price*quantity)) сортированный по сумме продаж по убыванию.
  
   2. Вывести ранг сотрудников по их зарплате, без пропусков. Также вывести имя, фамилию и должность.

17)Транзакции
  1. В рамках транзакции с уровнем изоляции Repeatable Read выполнить следующие операции:
  
  - заархивировать (SELECT INTO или CREATE TABLE AS) заказчиков, которые сделали покупок менее чем на 2000 у.е.
  - удалить из таблицы заказчиков всех заказчиков, которые были предварительно заархивированы (подсказка: для этого придётся удалить данные из связанных таблиц)
  
  2. В рамках транзакции выполнить следующие операции:
  - заархивировать все продукты, снятые с продажи (см. колонку discontinued)
  - поставить savepoint после архивации
  - удалить из таблицы продуктов все продукты, которые были заархивированы
  - откатиться к savepoint
  - закоммитить тразнакцию
